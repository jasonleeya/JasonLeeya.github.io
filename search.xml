<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试题汇总]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言马上就要参与到2019届毕业生的就业竞争中了，了解到前端面试很考验对前端基础知识的掌握，所以在网上搜罗了很多面试题，在此做个汇总。 基础问题讲讲输入完网址按下回车，到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 谈谈你对前端性能优化的理解 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验：避免CSS表达式，避免重定向 请简述盒模型文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。 请你谈谈Cookie的弊端 每个特定的域名下最多生成的cookie个数有限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。 浏览器本地存储在HTML5中提供了sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Cookie的大小是受限的 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽 cookie还需要指定作用域，不可以跨域调用 Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage 对BFC规范的理解BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动，防止与浮动元素重叠。 线程与进程的区别 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 请说出三种减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 你都使用哪些工具来测试代码的性能？开放题FireBug， JSPerf，Profiler（都没用过，直接F12…） 你遇到过比较难的技术问题是？你是如何解决的？开放题遇到的各种自己不会的新技术—到官网上找文档仔细阅读，写一个练习的demo边看文档边练习，遇到问题先遇到文档上解决不了的问题就上google问题，访问相关技术论坛，或者问询问懂的同事 跨域问题—设置代理 浏览器或者移动设备兼容和适配问题—查阅相关资料了解问题根源，再对不同设备编写相应代码、 内存溢出—通过不同手段找到内存溢出的问题所在做出相应调整 你常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？JQuery、Bootstarp、Vue、React、Node.js、axios… WebStorm、Sublime Text 、谷歌浏览器 轮播图插件、三级联动插件、标签栏插件、侧边栏导航插件 列举IE与其他浏览器不一样的特性？ IE的排版引擎是Trident （又称为MSHTML） Trident内核曾经几乎与W3C标准脱节（2005年） Trident内核的大量 Bug等安全性问题没有得到及时解决 JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等 CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 什么叫优雅降级和渐进增强？渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 对前端界面工程师这个职位是怎么样理解的？ 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你在现在的团队处于什么样的角色，起到了什么明显的作用？开放题与客户沟通了解客户需求，及时了解客户对项目的意见作出改变，与后端程序员和美工保持沟通时刻了解整体项目进度；对项目完成的速度会有很大影响。 你的优点是什么？缺点是什么？开放题优点：肯钻研、肯吃苦（不介意加班）、对工作很负责、喜欢学习新东西、善于和别人沟通、团队意识强。 缺点：有时候会对自己太严格，导致浪费很多不必要的时间和精力，我会在以后的工作中尽量克制自己，做到适可为止。 如何管理前端团队?开放题做到分工合理，了解团队中每个人的优缺点擅长和不擅长之处，做到对待每个人人人平等，提高团队的兴致，做好团队的榜样，带动每一个人参与合作。 最近在学什么？能谈谈你未来3，5年给自己的规划吗？开放题最近在学习React、TypeScript等前端前沿技术、未来3、5年内自己要不断学习新技术，提升自己的技术能力，争取成为一名优秀中高级前端工程师。 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 说说最近最流行的一些东西吧？常去哪些网站？MVVM框架：Vue、React、Anguler，Node.js，MongoDB… Google、GitHub、MDN、iconfont、CSDN、stackoverflow、SegmentFault… 请解释一下 JavaScript 的同源策略同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 网站重构的理解重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 a. 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) b. 对于移动平台的优化，针对于SEO进行优化 c. 减少代码间的耦合，让代码保持弹性 d. 压缩或合并JS、CSS、image等前端资源 前端页面有哪三层构成，分别是什么？作用是什么？ 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。 知道的网页制作会用到的图片格式有哪些？png-8，png-24，jpeg，gif，svg Webp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。 一次js请求一般情况下有哪些地方会有缓存处理？ 浏览器端存储 浏览器端文件缓存 HTTP缓存304 服务器端文件类型缓存 表现层&amp;DOM缓存 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 谈谈以前端角度出发做好SEO需要考虑什么？ 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 如何解决跨域问题原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 function createJs(sUrl){ var oScript =document.createElement('script'); oScript.type = 'text/javascript'; oScript.src= sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); } createJs('jsonp.js'); box({ 'name': 'test' }); function box(json){ alert(json.name); } CORS： 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 XML和JSON的区别？ .数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面。 JSON对数据的描述性比XML较差。 传输速度方面。 JSON的速度要远远快于XML。 谈谈你对webpack的看法WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： code splitting（可以自动完成） loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性： 对 CommonJS 、 AMD、ES6的语法做了兼容 对js、css、图片等资源文件都支持打包 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 有独立的配置文件webpack.config.js 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 支持 SourceUrls 和SourceMaps，易于调试 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 说说TCP传输的三次握手四次挥手策略为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 创建ajax过程 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. 常见web安全及防护原理sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： ​ 1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 ​ 2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 ​ 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 ​ 4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法记不住的读不懂的尚未学习知识的问题 HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 为什么HTTPS安全 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 Javascript垃圾回收方法标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 你觉得前端工程的价值体现在哪为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 谈谈性能优化问题为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 移动端性能优化 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 相关阅读：如何做到一秒渲染一个移动页面 栈和队列的区别?栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 快速 排序的思想并实现一个快排？“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 123456789101112131415161718192021&lt;scripttype=&quot;text/javascript&quot;&gt; functionquickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue =arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; returnquickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 &#125; alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” &lt;/script&gt; ES6的了解新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念 js继承方式及其优缺点原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 关于Http 2.0 你知道多少？HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 defer和asyncdefer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 用过哪些设计模式？工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 ​ 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法搞清楚他们到底是哪个对象的实例。 12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = newObject(); obj.name =name; obj.age = age; obj.profession= profession; obj.move =function () &#123; returnthis.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession; &#125;; return obj;&#125;var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 =createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 构造函数方法没有显示的创建对象 (new Object()); 直接将属性和方法赋值给 this 对象; 没有 renturn 语句。 说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（lia） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a: hover, li:nth-child） 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例： ​ p:first-of-type选择属于其父元素的首个 元素的每个 元素。 ​ p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 ​ p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 ​ p:only-child 选择属于其父元素的唯一子元素的每个 元素。 ​ p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 ​ :enabled :disabled控制表单控件的禁用状态。 ​ :checked 单选框或复选框被选中。 说说你对语义化的理解？ 去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 浮动元素引起的问题和解决办法？浮动元素引起的问题： 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： ​ .clearfix:after{content:”.”;display: block;height:0;clear: both;visibility: hidden;} .clearfix{display: inline-block;} /* for IE/Mac */ 清除浮动的几种方法： ​ 1. 额外标签法，&lt;divstyle=”clear:both;”&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。） ​ 2. 使用after伪类 1234567\#parent:after&#123; content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; &#125; ​ 3. 浮动外部元素 4. 设置overflow为hidden或者auto DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 创建新节点 ​ createDocumentFragment() //创建一个DOM片段 ​ createElement() //创建一个具体的元素 ​ createTextNode() //创建一个文本节点 添加、移除、替换、插入 ​ appendChild() ​ removeChild() ​ replaceChild() ​ insertBefore() //并没有insertAfter() 查找 ​ getElementsByTagName() //通过标签名称 ​ getElementsByName() //通过元素的Name属性的值(IE容错能力较强， ​ 会得到一个数组，其中包括id等于name值的) ​ getElementById() //通过元素Id，唯一性 如何实现浏览器内多个标签页之间的通信? 调用localstorge、cookies等本地存储方式 null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js call() 和 apply() 的作用？作用：动态改变某个类的某个方法的运行环境（执行上下文）。 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 请解释一下 JavaScript 的同源策略,为什么要有同源限制？概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么：我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点：现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 *GET和POST的区别，何时使用POST？、 GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 ​ POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 ​ GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， ​ 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； ev.stopPropagation();注意旧ie的方法ev.cancelBubble = true; HTTP状态码​ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 ​ 200 OK 正常返回信息 ​ 201 Created 请求成功并且服务器创建了新的资源 ​ 202 Accepted 服务器已接受请求，但尚未处理 ​ 301 Moved Permanently 请求的网页已永久移动到新位置。 ​ 302 Found 临时性重定向。 ​ 303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。 ​ 304 Not Modified 自从上次请求后，请求的网页未修改过。 ​ 400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 ​ 401 Unauthorized 请求未授权。 ​ 403Forbidden 禁止访问。 ​ 404 NotFound 找不到如何与 URI 相匹配的资源。 ​ 500 InternalServer Error 最常见的服务器端错误。 ​ 503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 1234567var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled对应 resolve, onRejected 对应 reject。 说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护；带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制1234567Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e inthis)&#123; o[e] = typeofthis[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o;&#125; 说说你对MVC和MVVM的理解MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 attribute和property的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的， 说说网络分层里七层模型是哪七层物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：①弱一致性（最终一致），更能保证用户的访问速度：②文档结构的存储方式，能够更便捷的获取数据。 讲讲304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 什么样的前端代码是好的高复用低耦合，这样文件小，好维护，而且好扩展。 看不懂没记住没了解知识点WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe 标签的长时间连接(可跨域) AMD和CMD 规范的区别？AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现 CMD 按需执行依赖 - 懒执行，seaJS 是它的实现 对前端模块化的认识AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 ​ define(function(require, exports,module) { ​ // 模块代码 ​ }); 浏览器的内核分别是什么?IE浏览器的内核Trident； Mozilla的Gecko； Chrome的Blink（WebKit的分支）； Opera内核原为Presto，现为Blink； 请介绍下cache-control每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略 Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久 Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。 Web Worker 和webSocketworker主线程: ​ 1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 ​ 2.通过worker.postMessage( data) 方法来向worker发送数据。 ​ 3.绑定worker.onmessage方法来接收worker发送过来的数据。 ​ 4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 什么是Etag？当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？ FOUC - FlashOf Unstyled Content 文档样式闪烁 1&lt;styletype=&quot;text/css&quot;media=&quot;all&quot;&gt;@import&quot;../fouc.css&quot;;&lt;/style&gt;​ 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 ​ 解决方法简单的出奇，只要在之间加入一个或者元素就可以了。 更多面试题详见下面PDF​]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础课程学习]]></title>
    <url>%2F2019%2F06%2F04%2FReact%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React基础课程学习raect]]></content>
      <categories>
        <category>学习历程</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识MarkDown]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%88%9D%E8%AF%86MarkDown%2F</url>
    <content type="text"><![CDATA[前言Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Hexo可以通过MarkDown的.md文件生成文章，所以学习MarkDown语法是很有必要的。 编辑器推荐在此推荐一款灰常好用的MarkDown编辑器—Typora,此编辑器可以在编写MarkDown语句时实时将效果展示在编辑器中，较传统MarkDown编辑器更加方便。 语法标题设置标题的做法是在想要设置成标题的文字前加#，#是一级标题，##是二级标题，以此类推，最小是六级标题。 注：#和文字中间要加空格。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体字体用法及效果如下： **加粗** =&gt; 加粗 *斜体* =&gt; 斜体 ***斜体加粗*** =&gt; 斜体加粗 ~~删除线~~ =&gt; 删除线 引用在引用的文字前加&gt;即可: 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 -或者 *都可以。 1234-------******** 效果如下： 图片1![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： 李双江的博客 列表无序列表语法：无序列表用- + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格表格 语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下： 由于Hexo不支持流程图，所以我放上截图： 本文参考至简书作者高鸿祥-Markdown基本语法]]></content>
      <categories>
        <category>学习历程</category>
      </categories>
      <tags>
        <tag>自学</tag>
        <tag>MarkDown</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题NexT的配置]]></title>
    <url>%2F2019%2F06%2F01%2FHexo%E4%B8%BB%E9%A2%98NexT%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言个人认为Hexo提供的默认主题实在是太丑了，好在Hexo官方提供了很多主题可以选择https://hexo.io/themes经过细心挑选，我选择了NexT主题，NexT主题页面简洁优美，功能齐全，文档丰富，下面我将对NexT进行配置。 安装主题安装NexT只需要在博客更目录打开命令行输入： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 启用NexT主题打开站点配置文件：hexo/_config.yml找到theme更改如下： 1theme: next hexo s启动本地服务器控制台输出： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 这是打开浏览器访问：http://localhost:4000，这是可以发现Hexo默认主题已经变为NexT主题。 NexT配置选择方案NexT支持四种不同风格的布局方案： Muse→默认方案，这是NexT的初始版本。使用黑白色调，主要看起来干净。 Mist →更紧凑的Muse版本，单列视图整齐。 Pisces→双栏计划，像你邻居的女儿一样新鲜。 Gemini→看起来像双鱼座，但有不同的带阴影的列块对视图更敏感。 这里我选择了Gemini,next/_config.yml搜索关键词schema配置如下： 1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 语言选择NexT主题文字默认是英文的，hexo/config.yml搜索关键词language配置如下： 1language: zh-CN 菜单设置设置导航栏的菜单选项，next/_config.yml搜索关键词menu，菜单item格式为Key: /link/ || icon key为菜单标题，link为路由链接，icon为菜单图标，可以在Font Awesome官网找到合适的图标名称并填入。 这里为将菜单栏设置如下： 1234home: / || hometags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive 如需自定义菜单和页面，可以参考官网文档自定义页面。 头像设置在主题目录下source/images/存放你的头像文件，并在next/_config.yml配置avatar 1avatar: /images/avatar.png。 设置标签分类页面在菜单栏里我们已经设置了分类和标签两个item,但是点进去却是Cannot GET /tags/这是因为我们还没有这两个页面，用： 1hexo new page &apos;name&apos; //name为创建的页面名称 分别创建tags、categories页面，这是我们可以看到source目录下已经多出了tags、categories两个文件夹。将这两个文件夹下index.md文件修改如下： 12345---title: tagsdate: 2018-01-04 11:45:41type: tags--- 每次新怎文章时增加上tags和categories属性值，就能在标签和分类页面有所展示了。 第三方插件静态网站在某些功能上受到限制，但我们可以通过第三方服务来扩展我们的网站。 添加fork me on github在http://tholman.com/github-corners选择合适的样式并复制代码到themes/next/layout/_layout.swig 添加到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 文章评论系统官网文档评论插件提供了多种添加插件的方法，但大部分被墙不能使用，而国内的插件只有Valine不收费，所以我选择了Valine。Valine配置如下： 创建一个Valine账号并登陆，点击创建应用： 点击设置&gt;应用Key获取App ID和AppKey： 在next/_config.yml中配置如下： 1234567891011valine: enable: true appid: # 你的App ID appkey: # 你的App Key notify: false verify: false placeholder: Just go go avatar: mm guest_info: nick,mail,link pageSize: 10 visitor: false hexo s打开本地服务器并访问文章页面，在文尾多出了评论组建。 动态背景cd到next文件夹输入： 1git clone https://github.com/theme-next/theme-next-three source/lib/three next/_config.yml配置： 12vendors: canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js hexo/_config.yml配置： 12# canvas_linescanvas_lines: false hexo s打开本地服务器访问网站会发现背景有动态线条。 开启搜索功能cd博客根目录安装hexo-generator-searchdb： 1npm install hexo-generator-searchdb --save hexo/_config.yml配置： 12345search: path: search.xml field: post format: html limit: 10000 next/_config.yml配置： 12345local_search: enable: true trigger: auto top_n_per_article: 1 unescape: false 重启服务器会发现侧边导航栏会出现搜索选项。 添加一键分享功能next/_config.yml配置： 12baidushare: type: button 添加背景音乐下载Aplayer源码并解压至themes\next\source文件夹下。 新建themes\next\source\dist\music.js文件，添加内容： 1234567891011121314151617const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;Es ware schon gewesen&quot;, artist: &apos;Ulli Bögershausen&apos;, url: &apos;http://music.163.com/song/media/outer/url?id=2065349.mp3&apos;, cover: &apos;http://p1.music.126.net/GrBJUAYcfgwbaZywULYwMA==/931286348781408.jpg&apos;, &#125;,&#123; name: &quot;So Cute~&quot;, artist: &apos;Lopu$&apos;, url: &apos;http://music.163.com/song/media/outer/url?id=433107530.mp3&apos;, cover: &apos;http://p1.music.126.net/yFCpD3GrgmcInAbVvVaFUg==/17999005346907556.jpg&apos;, &#125;]&#125;); audio:[]是音乐列表，复制一个音乐对象，浏览器打开并登陆网易云音乐，找到想要添加的歌曲，地址栏复制id值，在音乐对象的url中替换其中的id值，回到浏览器右键歌曲封面图片复制地址，替换音乐对象的cover，一首歌曲便添加成功了。 打开themes\next\layout\_layout.swig文件，将 1234&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 添加到&lt;body itemscope ...&gt;后面就行，即在&lt;body&gt;&lt;/body&gt;里面。 重新生成，访问页面，就能看到左下角的音乐播放器了。 以上便是我的博客NexT主题的配置，详细配置见NexT官网。]]></content>
      <categories>
        <category>技术贴</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+Hexo搭建博客]]></title>
    <url>%2F2019%2F05%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言一直有自己搭建个人博客的想法，但工作在身一直没有时间折腾，偶然发现GitHub有个牛比的功能——GitHub Page，可以将静态博客页面托管到上面，而且通过Hexo框架可以快速生成博客网站，并通过MarkDown 生成文章。 建立博客步骤 安装Git 安装Node.Js 安装Hexo 创建GitHub仓库 生成SSH并添加到GitHub 将Hexo博客部署到GitHub 设置域名 发布文章 安装GitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。我们通过它来对博客进行版本控制以及与GitHub进行连接，我们通过Git官网下载Git并安装。功能非常强大，有兴趣可以了解廖雪峰老师的Git教程。 安装Node.jsNode 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。Hexo是用Node.js编写的，所以需要安装Node.js以及Node.js的包管理工具NPM。 安装Hexo安装好Git与Node.js后，创建文件夹blog,进入blog文件夹（你也可以直接在桌面）按住shift+鼠标右键，右键菜单找到在此处打开CMD窗口,你也可以直接win+r输入cmd再cd到blog文件夹，执行命令： 1npm install -g hexo-cli 等安装完后用hexo v查看hexo版本确定是否安装成功 接下来初始化hexo: 1hexo init myblog //这个顺便取什么名字都行 然后安装依赖包： 1npm install 安装完后blog会多出很多文件夹以及文件： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章以及资源 themes：主题 _config.yml: 博客的配置文件 执行： 12hexo g //generatehexo s //serve 打开服务器，并打开浏览器输入localhost:4000，就可以看到你创建的博客网站了。 命令行ctrl+c关掉服务器 创建GitHub仓库首先你得有个github账号，如果没得就去注册一个吧 注册完后在你的首页可以看到New repository，点击新建仓库 创建一个和你用户名相同（不一样域名会很长）的仓库，后面加上github.io（只有这样github才能将此仓库识别为GitHub Page仓库）。然后具体的git操作我将不再赘述，具体详见廖雪峰老师的Git教程。 生成SSH并添加到GitHub在你博客文件夹右键Git Bash Here,执行： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname为你的Github用户名，youremail为你的Github绑定邮箱。 一路回车直到显示： 1ssh-keygen -t rsa -C &quot;youremail&quot; 输入你的邮箱并回车创建SSH,创建完成后会提示生成的.ssh文件的未知，找到这个文件夹,id_rsa为私钥，保存于电脑，不能将此分享给别人，id_rsa_pub为公钥，将此放到Github上，Github通过此与你电脑里的私钥进行匹配，只有匹配成功后才能git与你电脑进行文件传输。 进去Github，点击头像找到setting,找到侧边栏的SSH and GPG keys,点击New SSH key,输入窗口title可以随便填，将公钥内容填入key中。 gitbash执行： 1ssh -T git@github.com 查看公钥是否添加成功。 将hexo部署到github打开myblog文件夹下的配置文件 _config.yml，在文件最下面添加： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master repo为你的博客仓库地址。 打开命令行，cd到不可目录，安装deploy-git，这样才能用命令行将不可部署到Github 1npm install hexo-deployer-git --save 然后依次执行 123hexo cleanhexo generatehexo deploy hexo clean清除缓存，简写为hexo c可省略。hexo generate 生成静态文章，简写为hexo ghexo deploy 部署文章，简写为hexo d 待部署完成后你就可以到http://yourname.github.io查看的博客了。 域名设置你或许觉得github提供的域名太长，BIG不高，亦或许你有更好的域名，那没关系，GitHub Page可以实现自定义域名。 在阿里云或者腾讯云购买一个域名，具体怎么购买自行查阅相关资料，打开域名控制台，点击域名后面的解析添加解析，最好选CNAME解析，解析到你的项目地址。 进入Github中你的博客仓库点击setting,找到Custom domain，设置你的域名。 进入你的博客文件夹创建一个名为CNAME的文件，不要后缀，打开CNAME,写入你的域名（没有设置这个文件hexo的每次 deploy都将清除Github上你的Custom domain，每次都要重新进行设置） 这样，你就可以通过你自定义的域名进入你的博客了。 发布文章博客根目录下gitbash输入 1hexo new newpapername //newpapername为博客名 会在source/_post中生成新的博客，写完博客后 123hexo cleanhexo ghexo d 你就可以在你的博客下看到你新怎的博客了。]]></content>
      <categories>
        <category>技术贴</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>域名</tag>
      </tags>
  </entry>
</search>
